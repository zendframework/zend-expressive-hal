{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hypertext Application Language (HAL) for PSR-7 Applications This library provides utilities for modeling HAL resources with links and generating PSR-7 responses representing both JSON and XML serializations of them. Installation Run the following to install this library: $ composer require zendframework/zend-expressive-hal Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#hypertext-application-language-hal-for-psr-7-applications","text":"This library provides utilities for modeling HAL resources with links and generating PSR-7 responses representing both JSON and XML serializations of them.","title":"Hypertext Application Language (HAL) for PSR-7 Applications"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-hal","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"doctrine/","text":"Generating HAL from Doctrine Since 1.3.0 Doctrine is a well-known and popular Object Relational Mapper; you will find it in use across pretty much every PHP framework. Expressive is no different. How do you generate HAL for Doctrine resources? As it turns out, the same way you would for any other objects you might have: create metadata mapping the objects you want to represent to the routes and the hydrators/collections to use when extracting them. Example: Paginated Albums In this example, we have an entity named Album that we want to expose via a paginated HAL representation. Over the course of the example, we will create a custom collection class based off of the Doctrine Paginator class, and map it as a HAL collection. Our first step is defining an entity: declare(strict_types=1); namespace Album\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Ramsey\\Uuid\\Uuid; /** * https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html * * @ORM\\Entity * @ORM\\Table(name=\"albums\") **/ class Album { /** * @var Uuid * * @ORM\\Id * @ORM\\Column(type=\"uuid\", unique=true) * @ORM\\GeneratedValue(strategy=\"CUSTOM\") * @ORM\\CustomIdGenerator(class=\"Ramsey\\Uuid\\Doctrine\\UuidGenerator\") */ protected $id; /** * @ORM\\Column(type=\"string\", nullable=false) */ protected $title; /** * @ORM\\Column(type=\"datetime\", nullable=false) */ protected $created; /** * @ORM\\Column(type=\"datetime\") */ protected $modified; /** * @return Uuid */ public function getId(): Uuid { return $this->id; } /** * @return string */ public function getTitle(): string { return $this->title; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @return \\DateTime */ public function getCreated(): \\DateTime { return $this->created; } /** * @param \\DateTime $created * @throws \\Exception */ public function setCreated(\\DateTime $created = null): void { if (!$created && empty($this->getId())) { $this->created = new \\DateTime(\"now\"); } else { $this->created = $created; } } /** * @return \\DateTime */ public function getModified(): \\DateTime { return $this->modified; } /** * @param \\DateTime $modified * @throws \\Exception */ public function setModified(\\DateTime $modified = null): void { if (!$modified) { $this->modified = new \\DateTime(\"now\"); } else { $this->modified = $modified; } } } In order to work with this, we need to provide Doctrine persistence mapping configuration. We will do this in the ConfigProvider for this module: declare(strict_types=1); namespace Album; use Doctrine\\Common\\Persistence\\Mapping\\Driver\\MappingDriverChain; use Doctrine\\ORM\\Mapping\\Driver\\AnnotationDriver; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), 'doctrine' => $this->getDoctrineEntities(), ]; } public function getDependencies() : array { return [ ]; } public function getDoctrineEntities() : array { return [ 'driver' => [ 'orm_default' => [ 'class' => MappingDriverChain::class, 'drivers' => [ 'Album\\Entity' => 'album_entity', ], ], 'album_entity' => [ 'class' => AnnotationDriver::class, 'cache' => 'array', 'paths' => [__DIR__ . '/Entity'], ], ], ]; } } Next, in order to provide a HAL collection representation, we will create a custom Doctrine\\ORM\\Tools\\Pagination\\Paginator extension: declare(strict_types=1); namespace Album\\Entity; use Doctrine\\ORM\\Tools\\Pagination\\Paginator; class AlbumCollection extends Paginator { } From here, we will add configuration of our HAL metadata map to the ConfigProvider . First, we will add the following method to configure both our entity and our collection: // Add these imports to the top of the class file use Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata; use Zend\\Hydrator\\ReflectionHydrator; // Add this method inside the ConfigProvider class: public function getHalMetadataMap() { return [ [ '__class__' => RouteBasedResourceMetadata::class, 'resource_class' => Entity\\Album::class, 'route' => 'albums.show', // assumes a route named 'albums.show' has been created 'extractor' => ReflectionHydrator::class, ], [ '__class__' => RouteBasedCollectionMetadata::class, 'collection_class' => Entity\\AlbumCollection::class, 'collection_relation' => 'album', 'route' => 'albums.list', // assumes a route named 'albums.list' has been created ], ]; } Then, within the __invoke() method, we will assign the return value of that method to the key MetadataMap::class : // Add this import to the top of the class file: use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; // Modify this ConfigProvider method to read: public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), 'templates' => $this->getTemplates(), 'doctrine' => $this->getDoctrineEntities(), MetadataMap::class => $this->getHalMetadataMap(), ]; } With these in place, we can write a handler that will display a collection as follows: declare(strict_types=1); namespace Album\\Handler; use Album\\Entity\\Album; use Album\\Entity\\AlbumCollection; use Doctrine\\ORM\\EntityManager; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class ListAlbumsHandler implements RequestHandlerInterface { protected $entityManager; protected $pageCount; protected $responseFactory; protected $resourceGenerator; public function __construct( EntityManager $entityManager, int $pageCount, HalResponseFactory $responseFactory, ResourceGenerator $resourceGenerator ) { $this->entityManager = $entityManager; $this->pageCount = $pageCount; $this->responseFactory = $responseFactory; $this->resourceGenerator = $resourceGenerator; } public function handle(ServerRequestInterface $request) : ResponseInterface { $repository = $this->entityManager->getRepository(Album::class); $query = $repository ->createQueryBuilder('c') ->getQuery(); $query->setMaxResults($this->pageCount); $paginator = new AlbumCollection($query); $resource = $this->resourceGenerator->fromObject($paginator, $request); return $this->responseFactory->createResponse($request, $resource); } } And another handler for displaying an individual album: declare(strict_types=1); namespace Album\\Handler; use Album\\Entity\\Album; use Doctrine\\ORM\\EntityManager; use Zend\\Expressive\\Helper\\ServerUrlHelper; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class ShowAlbumHandler implements RequestHandlerInterface { protected $entityManager; protected $urlHelper; /** * AnnouncementsViewHandler constructor. * @param EntityManager $entityManager * @param ServerUrlHelper $urlHelper */ public function __construct( EntityManager $entityManager, ) { $this->entityManager = $entityManager; } /** * @param ServerRequestInterface $request * @return ResponseInterface */ public function handle(ServerRequestInterface $request) : ResponseInterface { $entityRepository = $this->entityManager->getRepository(Album::class); $result = $entityRepository->find($request->getAttribute('id')); if (empty($return)) { throw new RuntimeException('Not Found', 404); } $resource = $this->resourceGenerator->fromObject($result, $request); return $this->responseFactory->createResponse($request, $resource); } } In the above example, we map our Album entity such that: it is route-based; we will generate relational links to such entities based on existing routing definitions. (In this example, \"albums.show\".) it uses the ReflectionHydrator from the zend-hydrator package to extract a representation of the object to use with HAL. For our AlbumCollection , we define it such that: it, too, is route-based. (In this example, it maps to the route \"albums.list\".) the collection will map to the property \"album\". Since these mappings are in place, our handlers need only use the Doctrine EntityManager in order to retrieve the appropriate repository, and from there either retrieve appropriate entities (in the case of the ShowAlbumHandler ), or seed a collection paginator (in the case of the ListAlbumsHandler ). These values are known by the metadata map, and, as such, we can generate HAL resources for them without needing any other information. Setting the offset When you plan to use paginated Doctrine result sets, you DO NOT need to call $query->setFirstResult() . This will be called when generating the result set based on the current page and the value of $query->getMaxResults() . You MUST call $query->setMaxResults() prior to generating your resource if you want it to be paginated, however. Example: Doctrine Collections Sometimes we will want to return an entire collection at once. The getResult() method of Doctrine\\ORM\\Query will return an array of results by default, with each item in the array an object based on provided mappings. zend-expressive-hal will not work with arrays by default, as it needs a typed object in order to appropriately map it to a representation. To accomplish this, then, we have several options: Create a custom extension of an SPL iterator such as ArrayIterator to wrap the results. Create a custom extension of something like Doctrine\\Common\\Collections\\ArrayCollection to wrap the results. The following examples are based on the paginated collection from above; familiarize yourself with that code before continuing. The first change we will make is to modify our AlbumCollection to extend the Doctrine ArrayCollection , instead of its Paginator : namespace Album\\Entity; use Doctrine\\Common\\Collections\\ArrayCollection; class AlbumCollection extends ArrayCollection { } The only other changes we then need to make are to our ListAlbumsHandler : public function handle(ServerRequestInterface $request) : ResponseInterface { $repository = $this->entityManager->getRepository(Album::class); // Note that this removes the call to setMaxResults() $query = $repository ->createQueryBuilder('c') ->getQuery(); // Note that we pass the collection class the query result, and not the // query instance: $collection = new AlbumCollection($query->getResult()); $resource = $this->resourceGenerator->fromObject($collection, $request); return $this->responseFactory->createResponse($request, $resource); } With these in place, we will now get representation of all items returned by the query.","title":"Generating HAL for Doctrine Entities"},{"location":"doctrine/#generating-hal-from-doctrine","text":"Since 1.3.0 Doctrine is a well-known and popular Object Relational Mapper; you will find it in use across pretty much every PHP framework. Expressive is no different. How do you generate HAL for Doctrine resources? As it turns out, the same way you would for any other objects you might have: create metadata mapping the objects you want to represent to the routes and the hydrators/collections to use when extracting them.","title":"Generating HAL from Doctrine"},{"location":"doctrine/#example-paginated-albums","text":"In this example, we have an entity named Album that we want to expose via a paginated HAL representation. Over the course of the example, we will create a custom collection class based off of the Doctrine Paginator class, and map it as a HAL collection. Our first step is defining an entity: declare(strict_types=1); namespace Album\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Ramsey\\Uuid\\Uuid; /** * https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html * * @ORM\\Entity * @ORM\\Table(name=\"albums\") **/ class Album { /** * @var Uuid * * @ORM\\Id * @ORM\\Column(type=\"uuid\", unique=true) * @ORM\\GeneratedValue(strategy=\"CUSTOM\") * @ORM\\CustomIdGenerator(class=\"Ramsey\\Uuid\\Doctrine\\UuidGenerator\") */ protected $id; /** * @ORM\\Column(type=\"string\", nullable=false) */ protected $title; /** * @ORM\\Column(type=\"datetime\", nullable=false) */ protected $created; /** * @ORM\\Column(type=\"datetime\") */ protected $modified; /** * @return Uuid */ public function getId(): Uuid { return $this->id; } /** * @return string */ public function getTitle(): string { return $this->title; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @return \\DateTime */ public function getCreated(): \\DateTime { return $this->created; } /** * @param \\DateTime $created * @throws \\Exception */ public function setCreated(\\DateTime $created = null): void { if (!$created && empty($this->getId())) { $this->created = new \\DateTime(\"now\"); } else { $this->created = $created; } } /** * @return \\DateTime */ public function getModified(): \\DateTime { return $this->modified; } /** * @param \\DateTime $modified * @throws \\Exception */ public function setModified(\\DateTime $modified = null): void { if (!$modified) { $this->modified = new \\DateTime(\"now\"); } else { $this->modified = $modified; } } } In order to work with this, we need to provide Doctrine persistence mapping configuration. We will do this in the ConfigProvider for this module: declare(strict_types=1); namespace Album; use Doctrine\\Common\\Persistence\\Mapping\\Driver\\MappingDriverChain; use Doctrine\\ORM\\Mapping\\Driver\\AnnotationDriver; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), 'doctrine' => $this->getDoctrineEntities(), ]; } public function getDependencies() : array { return [ ]; } public function getDoctrineEntities() : array { return [ 'driver' => [ 'orm_default' => [ 'class' => MappingDriverChain::class, 'drivers' => [ 'Album\\Entity' => 'album_entity', ], ], 'album_entity' => [ 'class' => AnnotationDriver::class, 'cache' => 'array', 'paths' => [__DIR__ . '/Entity'], ], ], ]; } } Next, in order to provide a HAL collection representation, we will create a custom Doctrine\\ORM\\Tools\\Pagination\\Paginator extension: declare(strict_types=1); namespace Album\\Entity; use Doctrine\\ORM\\Tools\\Pagination\\Paginator; class AlbumCollection extends Paginator { } From here, we will add configuration of our HAL metadata map to the ConfigProvider . First, we will add the following method to configure both our entity and our collection: // Add these imports to the top of the class file use Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata; use Zend\\Hydrator\\ReflectionHydrator; // Add this method inside the ConfigProvider class: public function getHalMetadataMap() { return [ [ '__class__' => RouteBasedResourceMetadata::class, 'resource_class' => Entity\\Album::class, 'route' => 'albums.show', // assumes a route named 'albums.show' has been created 'extractor' => ReflectionHydrator::class, ], [ '__class__' => RouteBasedCollectionMetadata::class, 'collection_class' => Entity\\AlbumCollection::class, 'collection_relation' => 'album', 'route' => 'albums.list', // assumes a route named 'albums.list' has been created ], ]; } Then, within the __invoke() method, we will assign the return value of that method to the key MetadataMap::class : // Add this import to the top of the class file: use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; // Modify this ConfigProvider method to read: public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), 'templates' => $this->getTemplates(), 'doctrine' => $this->getDoctrineEntities(), MetadataMap::class => $this->getHalMetadataMap(), ]; } With these in place, we can write a handler that will display a collection as follows: declare(strict_types=1); namespace Album\\Handler; use Album\\Entity\\Album; use Album\\Entity\\AlbumCollection; use Doctrine\\ORM\\EntityManager; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class ListAlbumsHandler implements RequestHandlerInterface { protected $entityManager; protected $pageCount; protected $responseFactory; protected $resourceGenerator; public function __construct( EntityManager $entityManager, int $pageCount, HalResponseFactory $responseFactory, ResourceGenerator $resourceGenerator ) { $this->entityManager = $entityManager; $this->pageCount = $pageCount; $this->responseFactory = $responseFactory; $this->resourceGenerator = $resourceGenerator; } public function handle(ServerRequestInterface $request) : ResponseInterface { $repository = $this->entityManager->getRepository(Album::class); $query = $repository ->createQueryBuilder('c') ->getQuery(); $query->setMaxResults($this->pageCount); $paginator = new AlbumCollection($query); $resource = $this->resourceGenerator->fromObject($paginator, $request); return $this->responseFactory->createResponse($request, $resource); } } And another handler for displaying an individual album: declare(strict_types=1); namespace Album\\Handler; use Album\\Entity\\Album; use Doctrine\\ORM\\EntityManager; use Zend\\Expressive\\Helper\\ServerUrlHelper; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class ShowAlbumHandler implements RequestHandlerInterface { protected $entityManager; protected $urlHelper; /** * AnnouncementsViewHandler constructor. * @param EntityManager $entityManager * @param ServerUrlHelper $urlHelper */ public function __construct( EntityManager $entityManager, ) { $this->entityManager = $entityManager; } /** * @param ServerRequestInterface $request * @return ResponseInterface */ public function handle(ServerRequestInterface $request) : ResponseInterface { $entityRepository = $this->entityManager->getRepository(Album::class); $result = $entityRepository->find($request->getAttribute('id')); if (empty($return)) { throw new RuntimeException('Not Found', 404); } $resource = $this->resourceGenerator->fromObject($result, $request); return $this->responseFactory->createResponse($request, $resource); } } In the above example, we map our Album entity such that: it is route-based; we will generate relational links to such entities based on existing routing definitions. (In this example, \"albums.show\".) it uses the ReflectionHydrator from the zend-hydrator package to extract a representation of the object to use with HAL. For our AlbumCollection , we define it such that: it, too, is route-based. (In this example, it maps to the route \"albums.list\".) the collection will map to the property \"album\". Since these mappings are in place, our handlers need only use the Doctrine EntityManager in order to retrieve the appropriate repository, and from there either retrieve appropriate entities (in the case of the ShowAlbumHandler ), or seed a collection paginator (in the case of the ListAlbumsHandler ). These values are known by the metadata map, and, as such, we can generate HAL resources for them without needing any other information.","title":"Example: Paginated Albums"},{"location":"doctrine/#example-doctrine-collections","text":"Sometimes we will want to return an entire collection at once. The getResult() method of Doctrine\\ORM\\Query will return an array of results by default, with each item in the array an object based on provided mappings. zend-expressive-hal will not work with arrays by default, as it needs a typed object in order to appropriately map it to a representation. To accomplish this, then, we have several options: Create a custom extension of an SPL iterator such as ArrayIterator to wrap the results. Create a custom extension of something like Doctrine\\Common\\Collections\\ArrayCollection to wrap the results. The following examples are based on the paginated collection from above; familiarize yourself with that code before continuing. The first change we will make is to modify our AlbumCollection to extend the Doctrine ArrayCollection , instead of its Paginator : namespace Album\\Entity; use Doctrine\\Common\\Collections\\ArrayCollection; class AlbumCollection extends ArrayCollection { } The only other changes we then need to make are to our ListAlbumsHandler : public function handle(ServerRequestInterface $request) : ResponseInterface { $repository = $this->entityManager->getRepository(Album::class); // Note that this removes the call to setMaxResults() $query = $repository ->createQueryBuilder('c') ->getQuery(); // Note that we pass the collection class the query result, and not the // query instance: $collection = new AlbumCollection($query->getResult()); $resource = $this->resourceGenerator->fromObject($collection, $request); return $this->responseFactory->createResponse($request, $resource); } With these in place, we will now get representation of all items returned by the query.","title":"Example: Doctrine Collections"},{"location":"factories/","text":"Provided factories This component provides a number of factories for use with PSR-11 , in order to generate fully configured instances for your use. Zend\\Expressive\\Hal\\HalResponseFactoryFactory Registered as service: Zend\\Expressive\\Hal\\HalResponseFactory Generates instance of: Zend\\Expressive\\Hal\\HalResponseFactory Depends on: Psr\\Http\\Message\\ResponseInterface service. The service must resolve to a PHP callable capable of generating a PSR-7 ResponseInterface instance; it must not resolve to a ResponseInterface instance directly. This service is required , and must be supplied by the application. If you are using with zend-expressive v3 and above, the service will already be registered. Zend\\Expressive\\Hal\\Renderer\\JsonRenderer service. If the service is not present, it instantiates an instance itself. Zend\\Expressive\\Hal\\Renderer\\XmlRenderer service. If the service is not present, it instantiates an instance itself. Zend\\Expressive\\Hal\\LinkGeneratorFactory Registered as service: Zend\\Expressive\\Hal\\LinkGenerator Generates instance of: Zend\\Expressive\\Hal\\LinkGenerator Depends on: Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface service Since version 1.1.0, this factory allows an optional constructor argument, $urlGeneratorServiceName . It defaults to Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance, and an alternate URL generator that consumes it. Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory Registered as service: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator Generates instance of: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator Depends on: zendframework/zend-expressive-helpers package Zend\\Expressive\\Helper\\UrlHelper service Zend\\Expressive\\Helper\\ServerUrlHelper service (optional; if not provided, URIs will be generated without authority information) Since version 1.1.0, this factory allows an optional constructor argument, $urlHelperServiceName . It defaults to Zend\\Expressive\\Helper\\UrlHelper , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance. Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface Registered as service: Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface Aliased to service: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator You can either define an alternate alias, or map the UrlGeneratorInterface service directly to a factory that will return a valid instance. Zend\\Expressive\\Hal\\Metadata\\MetadataMapFactory Registered as service: Zend\\Expressive\\Hal\\Metadata\\MetadataMap Generates instance of: Zend\\Expressive\\Hal\\Metadata\\MetadataMap Depends on: config service; if not present, will use an empty array This service uses the Zend\\Expressive\\Hal\\Metadata\\MetadataMap key of the config service in order to configure and return a Zend\\Expressive\\Hal\\Metadata\\MetadataMap instance. It expects that value to be an array of elements, each with the following structure: [ '__class__' => 'Fully qualified class name of an AbstractMetadata type', // additional key/value pairs as required by the metadata type. ] The additional pairs are as follows: For UrlBasedResourceMetadata : resource_class : the resource class the metadata describes. url : the URL to use when generating a self-relational link for the resource. extractor : the extractor/hydrator service to use to extract resource data. For UrlBasedCollectionMetadata : collection_class : the collection class the metadata describes. collection_relation : the embedded relation for the collection in the generated resource. url : the URL to use when generating a self-relational link for the collection resource. pagination_param : the name of the parameter indicating what page of data is present. Defaults to \"page\". pagination_param_type : whether the pagination parameter is a query string or path placeholder; use either AbstractCollectionMetadata::TYPE_QUERY (\"query\") or AbstractCollectionMetadata::TYPE_PLACEHOLDER (\"placeholder\"); default is \"query\". For RouteBasedResourceMetadata : resource_class : the resource class the metadata describes. route : the route to use when generating a self relational link for the resource. extractor : the extractor/hydrator service to use to extract resource data. resource_identifier : what property in the resource represents its identifier; defaults to \"id\". route_identifier_placeholder : what placeholder in the route string represents the resource identifier; defaults to \"id\". route_params : an array of additional routing parameters to use when generating the self relational link for the resource. For RouteBasedCollectionMetadata : collection_class : the collection class the metadata describes. collection_relation : the embedded relation for the collection in the generated resource. route : the route to use when generating a self relational link for the collection resource. pagination_param : the name of the parameter indicating what page of data is present. Defaults to \"page\". pagination_param_type : whether the pagination parameter is a query string or path placeholder; use either AbstractCollectionMetadata::TYPE_QUERY (\"query\") or AbstractCollectionMetadata::TYPE_PLACEHOLDER (\"placeholder\"); default is \"query\". route_params : an array of additional routing parameters to use when generating the self relational link for the collection resource. Defaults to an empty array. query_string_arguments : an array of query string parameters to include when generating the self relational link for the collection resource. Defaults to an empty array. If you have created custom metadata types, you can extend this class to support them. Create create<type>(array $metadata) methods for each type you wish to support, where <type> is your custom class name, minus the namespace. Limitation There is a known limitation with zend-router when using routes with optional parameters (e.g., /books[/:id] , where :id is optional). In such cases, if no matching parameter is provided (such as when generating a URI without an :id ), the router will raise an exception due to the missing parameter. If you encounter this issue, create separate routing entries for each optional parameter. See the issue for a comprehensive example. Zend\\Expressive\\Hal\\ResourceGeneratorFactory Registered as service: Zend\\Expressive\\Hal\\ResourceGenerator Generates instance of: Zend\\Expressive\\Hal\\ResourceGenerator Depends on: Zend\\Expressive\\Hal\\Metadata\\MetadataMap service Zend\\Hydrator\\HydratorPluginManager service Zend\\Expressive\\Hal\\LinkGenerator service If you wish to use a container implementation other than the Zend\\Hydrator\\HydratorPluginManager , either register it under that service name, or create an alternate factory. Since version 1.1.0, this factory allows an optional constructor argument, $linkGeneratorServiceName . It defaults to Zend\\Expressive\\Hal\\LinkGenerator , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance, an alternate URL generator that consumes it, and an alternate LinkGenerator consuming the URL generator.","title":"Factories"},{"location":"factories/#provided-factories","text":"This component provides a number of factories for use with PSR-11 , in order to generate fully configured instances for your use.","title":"Provided factories"},{"location":"factories/#zendexpressivehalhalresponsefactoryfactory","text":"Registered as service: Zend\\Expressive\\Hal\\HalResponseFactory Generates instance of: Zend\\Expressive\\Hal\\HalResponseFactory Depends on: Psr\\Http\\Message\\ResponseInterface service. The service must resolve to a PHP callable capable of generating a PSR-7 ResponseInterface instance; it must not resolve to a ResponseInterface instance directly. This service is required , and must be supplied by the application. If you are using with zend-expressive v3 and above, the service will already be registered. Zend\\Expressive\\Hal\\Renderer\\JsonRenderer service. If the service is not present, it instantiates an instance itself. Zend\\Expressive\\Hal\\Renderer\\XmlRenderer service. If the service is not present, it instantiates an instance itself.","title":"Zend\\Expressive\\Hal\\HalResponseFactoryFactory"},{"location":"factories/#zendexpressivehallinkgeneratorfactory","text":"Registered as service: Zend\\Expressive\\Hal\\LinkGenerator Generates instance of: Zend\\Expressive\\Hal\\LinkGenerator Depends on: Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface service Since version 1.1.0, this factory allows an optional constructor argument, $urlGeneratorServiceName . It defaults to Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance, and an alternate URL generator that consumes it.","title":"Zend\\Expressive\\Hal\\LinkGeneratorFactory"},{"location":"factories/#zendexpressivehallinkgeneratorexpressiveurlgeneratorfactory","text":"Registered as service: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator Generates instance of: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator Depends on: zendframework/zend-expressive-helpers package Zend\\Expressive\\Helper\\UrlHelper service Zend\\Expressive\\Helper\\ServerUrlHelper service (optional; if not provided, URIs will be generated without authority information) Since version 1.1.0, this factory allows an optional constructor argument, $urlHelperServiceName . It defaults to Zend\\Expressive\\Helper\\UrlHelper , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance.","title":"Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory"},{"location":"factories/#zendexpressivehallinkgeneratorurlgeneratorinterface","text":"Registered as service: Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface Aliased to service: Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator You can either define an alternate alias, or map the UrlGeneratorInterface service directly to a factory that will return a valid instance.","title":"Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface"},{"location":"factories/#zendexpressivehalmetadatametadatamapfactory","text":"Registered as service: Zend\\Expressive\\Hal\\Metadata\\MetadataMap Generates instance of: Zend\\Expressive\\Hal\\Metadata\\MetadataMap Depends on: config service; if not present, will use an empty array This service uses the Zend\\Expressive\\Hal\\Metadata\\MetadataMap key of the config service in order to configure and return a Zend\\Expressive\\Hal\\Metadata\\MetadataMap instance. It expects that value to be an array of elements, each with the following structure: [ '__class__' => 'Fully qualified class name of an AbstractMetadata type', // additional key/value pairs as required by the metadata type. ] The additional pairs are as follows: For UrlBasedResourceMetadata : resource_class : the resource class the metadata describes. url : the URL to use when generating a self-relational link for the resource. extractor : the extractor/hydrator service to use to extract resource data. For UrlBasedCollectionMetadata : collection_class : the collection class the metadata describes. collection_relation : the embedded relation for the collection in the generated resource. url : the URL to use when generating a self-relational link for the collection resource. pagination_param : the name of the parameter indicating what page of data is present. Defaults to \"page\". pagination_param_type : whether the pagination parameter is a query string or path placeholder; use either AbstractCollectionMetadata::TYPE_QUERY (\"query\") or AbstractCollectionMetadata::TYPE_PLACEHOLDER (\"placeholder\"); default is \"query\". For RouteBasedResourceMetadata : resource_class : the resource class the metadata describes. route : the route to use when generating a self relational link for the resource. extractor : the extractor/hydrator service to use to extract resource data. resource_identifier : what property in the resource represents its identifier; defaults to \"id\". route_identifier_placeholder : what placeholder in the route string represents the resource identifier; defaults to \"id\". route_params : an array of additional routing parameters to use when generating the self relational link for the resource. For RouteBasedCollectionMetadata : collection_class : the collection class the metadata describes. collection_relation : the embedded relation for the collection in the generated resource. route : the route to use when generating a self relational link for the collection resource. pagination_param : the name of the parameter indicating what page of data is present. Defaults to \"page\". pagination_param_type : whether the pagination parameter is a query string or path placeholder; use either AbstractCollectionMetadata::TYPE_QUERY (\"query\") or AbstractCollectionMetadata::TYPE_PLACEHOLDER (\"placeholder\"); default is \"query\". route_params : an array of additional routing parameters to use when generating the self relational link for the collection resource. Defaults to an empty array. query_string_arguments : an array of query string parameters to include when generating the self relational link for the collection resource. Defaults to an empty array. If you have created custom metadata types, you can extend this class to support them. Create create<type>(array $metadata) methods for each type you wish to support, where <type> is your custom class name, minus the namespace.","title":"Zend\\Expressive\\Hal\\Metadata\\MetadataMapFactory"},{"location":"factories/#zendexpressivehalresourcegeneratorfactory","text":"Registered as service: Zend\\Expressive\\Hal\\ResourceGenerator Generates instance of: Zend\\Expressive\\Hal\\ResourceGenerator Depends on: Zend\\Expressive\\Hal\\Metadata\\MetadataMap service Zend\\Hydrator\\HydratorPluginManager service Zend\\Expressive\\Hal\\LinkGenerator service If you wish to use a container implementation other than the Zend\\Hydrator\\HydratorPluginManager , either register it under that service name, or create an alternate factory. Since version 1.1.0, this factory allows an optional constructor argument, $linkGeneratorServiceName . It defaults to Zend\\Expressive\\Hal\\LinkGenerator , but you may specify an alternate service if desired. This may be useful, for instance, when using an alternate router in a path-segregated middleware pipeline, which would necessitate a different UrlHelper instance, an alternate URL generator that consumes it, and an alternate LinkGenerator consuming the URL generator.","title":"Zend\\Expressive\\Hal\\ResourceGeneratorFactory"},{"location":"hal/","text":"Hypertext Application Language Hypertext Application Language , or HAL) is a proposed IETF specification for representing API resources and their relations with hyperlinks. While the original specification targets JSON, an additional IETF proposal targets XML . HAL is a minimal specification, and addresses three specific things: How to represent the elements of an API resource. How to represent hypertext links of an API resource. How to represent child resources. Resources HAL opts to keep out of the way. Where other specifications may push the data for a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL specifies resources as the primary payload. As such, a resource is simply a document : { \"id\": \"XXXX-YYYY-ZZZZ-AAAA\", \"title\": \"Life, the Universe, and Everything\", \"author\": \"Adams, Douglas\" } For XML documents, the element <resource> is reserved to detail the resource; every other element represents the document: <resource> <id>XXXX-YYYY-ZZZZ-AAAA</id> <title>Life, the Universe, and Everything</title> <author>Adams, Douglas</author> </resource> This decision makes both consuming and generating HAL payloads trivial. Links One goal of REST is to allow any given resource to provide hypertext controls , or links , allowing the consumer to know what they can do next. Most resources will provide a self relational link , so that the consumer knows how to request the resource again. However, a consumer might want to know what other actions are possible. For example, they may want to know: how to get a list of related resources how to access the first, previous, next, or last pages of a collection of resources what resources are related: e.g., transactions, products, invoices, users, etc. HAL addresses how to provide such links. This is necessary because JSON has no specific semantics around linking, and XML, while it has some semantics, does not cover how to provide multiple links for a given element. HAL addresses JSON by reserving a special _links property, and specifying a structure for how links are represented. Each element of the _links property is named for the link relation, and the value is either an array, or a link object. A link object contains minimally an href property, with several other properties allowed. As an example: { \"_links\": { \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" }, \"books\": { \"href\": \"/api/books\" } } } At this point, the consumer knows they can access the current resource via the \"self\" relation, and a collection of \"books\" via the URI \"/api/books\". HAL addresses links in XML with two semantics. First, the <resource> element can contain linking information, using the \"rel\" and \"href\" attributes (and any others necessary to describe the link). Typically, the \"self\" relational link is defined in the <resource> element. Second, the specification also reserves the <link> element; the relation, URI, and other attributes become attributes of that XML element. An equivalent XML document to the JSON document above looks like the following: <resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\"> <link rel=\"books\" href=\"/api/books\"/> </resource> Child Resources An API payload may have child resources for several reasons: The resource may be related to the current payload, and providing it directly would prevent another request to the API. The payload may represent a collection of resources (or even multiple collections of resources). Generally, a child resource represents a relation . As such, HAL has very specific semantics for providing them. In JSON documents, the specification reserves the property _embedded . This is an object, with the keys being the relations , and the values either resources, or arrays of resources. Each resource follows the same structure as a basic HAL resource, with a _links member, other members representing the resource, and optionally an _embedded member. { \"_links\": { \"self\": { \"href\": \"/api/books?page=7\" }, \"first\": { \"href\": \"/api/books?page=1\" }, \"prev\": { \"href\": \"/api/books?page=6\" }, \"next\": { \"href\": \"/api/books?page=8\" }, \"last\": { \"href\": \"/api/books?page=17\" } \"search\": { \"href\": \"/api/books?query={searchTerms}\", \"templated\": true } }, \"_embedded\": { \"book\": [ { \"_links\": { \"self\": { \"href\": \"/api/books/1234\" } } \"id\": 1234, \"title\": \"Hitchhiker's Guide to the Galaxy\", \"author\": \"Adams, Douglas\" }, { \"_links\": { \"self\": { \"href\": \"/api/books/6789\" } } \"id\": 6789, \"title\": \"Ancillary Justice\", \"author\": \"Leckie, Ann\" } ] }, \"_page\": 7, \"_per_page\": 2, \"_total\": 33 } The above represents a collection of book resources. To address XML, the specification uses the <resource> element to embed additional resources. Resources of the same type use the same rel attribute. The XML equivalent of the above JSON documentation thus becomes: <resource rel=\"self\" href=\"/api/books?page=7\"> <link rel=\"first\" href=\"/api/books?page=1\"/> <link rel=\"prev\" href=\"/api/books?page=6\"/> <link rel=\"next\" href=\"/api/books?page=8\"/> <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/> <resource rel=\"book\" href=\"/api/books/1234\"> <id>1234</id> <title>Hitchhiker's Guide to the Galaxy</title> <author>Adams, Douglas</author> </resource> <resource rel=\"book\" href=\"/api/books/6789\"> <id>6789</id> <title>Ancillary Justice</title> <author>Leckie, Ann</author> </resource> <_page>7</_page> <_per_page>2</_per_page> <_total>33</_total> </resource> Summary With these three semantics \u2014 resources, links, and child resources \u2014 HAL allows you to describe any payload, and provide the hypertext controls necessary to allow API consumers to know what resources they can access next. The next step, then, is learning how to create HAL payloads for your API!","title":"HAL"},{"location":"hal/#hypertext-application-language","text":"Hypertext Application Language , or HAL) is a proposed IETF specification for representing API resources and their relations with hyperlinks. While the original specification targets JSON, an additional IETF proposal targets XML . HAL is a minimal specification, and addresses three specific things: How to represent the elements of an API resource. How to represent hypertext links of an API resource. How to represent child resources.","title":"Hypertext Application Language"},{"location":"hal/#resources","text":"HAL opts to keep out of the way. Where other specifications may push the data for a resource into a subkey (e.g., \"data\", \"collection.items\", etc.), HAL specifies resources as the primary payload. As such, a resource is simply a document : { \"id\": \"XXXX-YYYY-ZZZZ-AAAA\", \"title\": \"Life, the Universe, and Everything\", \"author\": \"Adams, Douglas\" } For XML documents, the element <resource> is reserved to detail the resource; every other element represents the document: <resource> <id>XXXX-YYYY-ZZZZ-AAAA</id> <title>Life, the Universe, and Everything</title> <author>Adams, Douglas</author> </resource> This decision makes both consuming and generating HAL payloads trivial.","title":"Resources"},{"location":"hal/#links","text":"One goal of REST is to allow any given resource to provide hypertext controls , or links , allowing the consumer to know what they can do next. Most resources will provide a self relational link , so that the consumer knows how to request the resource again. However, a consumer might want to know what other actions are possible. For example, they may want to know: how to get a list of related resources how to access the first, previous, next, or last pages of a collection of resources what resources are related: e.g., transactions, products, invoices, users, etc. HAL addresses how to provide such links. This is necessary because JSON has no specific semantics around linking, and XML, while it has some semantics, does not cover how to provide multiple links for a given element. HAL addresses JSON by reserving a special _links property, and specifying a structure for how links are represented. Each element of the _links property is named for the link relation, and the value is either an array, or a link object. A link object contains minimally an href property, with several other properties allowed. As an example: { \"_links\": { \"self\": { \"href\": \"/api/books/XXXX-YYYY-ZZZZ-AAAA\" }, \"books\": { \"href\": \"/api/books\" } } } At this point, the consumer knows they can access the current resource via the \"self\" relation, and a collection of \"books\" via the URI \"/api/books\". HAL addresses links in XML with two semantics. First, the <resource> element can contain linking information, using the \"rel\" and \"href\" attributes (and any others necessary to describe the link). Typically, the \"self\" relational link is defined in the <resource> element. Second, the specification also reserves the <link> element; the relation, URI, and other attributes become attributes of that XML element. An equivalent XML document to the JSON document above looks like the following: <resource rel=\"self\" href=\"/api/books/XXXX-YYYY-ZZZZ-AAAA\"> <link rel=\"books\" href=\"/api/books\"/> </resource>","title":"Links"},{"location":"hal/#child-resources","text":"An API payload may have child resources for several reasons: The resource may be related to the current payload, and providing it directly would prevent another request to the API. The payload may represent a collection of resources (or even multiple collections of resources). Generally, a child resource represents a relation . As such, HAL has very specific semantics for providing them. In JSON documents, the specification reserves the property _embedded . This is an object, with the keys being the relations , and the values either resources, or arrays of resources. Each resource follows the same structure as a basic HAL resource, with a _links member, other members representing the resource, and optionally an _embedded member. { \"_links\": { \"self\": { \"href\": \"/api/books?page=7\" }, \"first\": { \"href\": \"/api/books?page=1\" }, \"prev\": { \"href\": \"/api/books?page=6\" }, \"next\": { \"href\": \"/api/books?page=8\" }, \"last\": { \"href\": \"/api/books?page=17\" } \"search\": { \"href\": \"/api/books?query={searchTerms}\", \"templated\": true } }, \"_embedded\": { \"book\": [ { \"_links\": { \"self\": { \"href\": \"/api/books/1234\" } } \"id\": 1234, \"title\": \"Hitchhiker's Guide to the Galaxy\", \"author\": \"Adams, Douglas\" }, { \"_links\": { \"self\": { \"href\": \"/api/books/6789\" } } \"id\": 6789, \"title\": \"Ancillary Justice\", \"author\": \"Leckie, Ann\" } ] }, \"_page\": 7, \"_per_page\": 2, \"_total\": 33 } The above represents a collection of book resources. To address XML, the specification uses the <resource> element to embed additional resources. Resources of the same type use the same rel attribute. The XML equivalent of the above JSON documentation thus becomes: <resource rel=\"self\" href=\"/api/books?page=7\"> <link rel=\"first\" href=\"/api/books?page=1\"/> <link rel=\"prev\" href=\"/api/books?page=6\"/> <link rel=\"next\" href=\"/api/books?page=8\"/> <link rel=\"last\" href=\"/api/books?page=17\" templated=\"true\"/> <resource rel=\"book\" href=\"/api/books/1234\"> <id>1234</id> <title>Hitchhiker's Guide to the Galaxy</title> <author>Adams, Douglas</author> </resource> <resource rel=\"book\" href=\"/api/books/6789\"> <id>6789</id> <title>Ancillary Justice</title> <author>Leckie, Ann</author> </resource> <_page>7</_page> <_per_page>2</_per_page> <_total>33</_total> </resource>","title":"Child Resources"},{"location":"hal/#summary","text":"With these three semantics \u2014 resources, links, and child resources \u2014 HAL allows you to describe any payload, and provide the hypertext controls necessary to allow API consumers to know what resources they can access next. The next step, then, is learning how to create HAL payloads for your API!","title":"Summary"},{"location":"intro/","text":"zend-expressive-hal This component provides tools for generating Hypertext Application Language (HAL) payloads for your APIs, in both JSON and XML formats. At its core, it features: Zend\\Expressive\\Hal\\Link , a value object for describing relational links . Zend\\Expressive\\Hal\\HalResource , a value object for describing your API resource, its relational links, and any embedded/child resources related to it. These two tools allow you to model payloads of varying complexity. To allow providing representations of these, we provide Zend\\Expressive\\Hal\\HalResponseFactory . This factory generates a PSR-7 response for the provided resource, including its links and any embedded/child resources it composes. Creating link URIs by hand is error-prone, as URI schemas may change; most frameworks provide route-based URI generation for this reason. To address this, we provide Zend\\Expressive\\Hal\\LinkGenerator , and an accompanying interface, Zend\\Expressive\\Hal\\LinkGenerator\\UrlGenerator . You may use these to generate Link instances that use URIs based on routes you have defined in your application. We also ship Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator , which provides a UrlGenerator implementation backed by the zend-expressive-helpers package. Finally, we recognize that most modern PHP applications use strong data modeling, and thus API payloads need to represent PHP objects . To facilitate this, we provide two components: Zend\\Expressive\\Hal\\Metadata is a subcomponent that allows mapping PHP objects to how they should be represented: Should a route be used to generate its self relational link? What zend-hydrator extractor should be used to create a representation of the object? Does the object represent a collection? etc. Zend\\Expressive\\Hal\\ResourceGenerator consumes metadata in order to generate HalResource instances, mapping metadata to specific representation strategies. The purpose of the package is to automate creation of HAL payloads, including relational links, from PHP objects. Installation Use Composer: $ composer require zendframework/zend-expressive-hal If you are adding this to an Expressive application, and have the zend-component-installer package installed, this will prompt you to ask if you wish to add it to your application configuration; please do, as the package provides a number of useful factories. We also recommend installing zend-hydrator , which provides facilities for extracting associative array representations of PHP objects: $ composer require zendframework/zend-hydrator Finally, if you want to provide paginated collections, we recommend installing zend-paginator : $ composer require zendframework/zend-paginator Quick Start The following examples assume that you have added this package to an Expressive application. Entity and collection classes For each of our examples, we'll assume the following class exists: namespace Api\\Books; class Book { public $id; public $title; public $author; } Additionally, we'll have a class representing a paginated group of books: namespace Api\\Books; use Zend\\Paginator\\Paginator; class BookCollection extends Paginator { } Routes The examples below assume that we have the following routes defined in our application somehow: \"book\" will map to a single book by identifier: \"/api/books/{id}\" \"books\" will map to a queryable collection endpoint: \"/api/books\" Create metadata In order to allow creating representations of these classes, we need to provide the resource generator with metadata describing them. This is done via configuration, which you could put in one of the following places: A new configuration file: config/autoload/hal.global.php . A ConfigProvider class: Api\\Books\\ConfigProvider . If you go this route, you will need to add an entry for this class to your config/config.php file. The configuration will look like this: // Provide the following imports: use Api\\Books\\Book; use Api\\Books\\BookCollection; use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata; use Zend\\Hydrator\\ObjectProperty as ObjectPropertyHydrator; // And include the following in your configuration: MetadataMap::class => [ [ '__class__' => RouteBasedResourceMetadata::class, 'resource_class' => Book::class, 'route' => 'book', 'extractor' => ObjectPropertyHydrator::class, ], [ '__class__' => RouteBasedCollectionMetadata::class, 'collection_class' => BookCollection::class, 'collection_relation' => 'book', 'route' => 'books', ], ], Manually creating and rendering a resource The following request handler creates a HalResource with its associated links, and then manually renders it using Zend\\Expressive\\Hal\\Renderer\\JsonRenderer . (An XmlRenderer is also provided, but not demonstrated here.) We'll assume that Api\\Books\\Repository handles retrieving data from persistent storage. namespace Api\\Books\\Action; use Api\\Books\\Repository; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use RuntimeException; use Zend\\Diactoros\\Response\\TextResponse; use Zend\\Expressive\\Hal\\HalResource; use Zend\\Expressive\\Hal\\Link; use Zend\\Expressive\\Hal\\Renderer\\JsonRenderer; class BookAction implements RequestHandlerInterface { /** @var JsonRenderer */ private $renderer; /** @var Repository */ private $repository; public function __construct( Repository $repository, JsonRenderer $renderer ) { $this->repository = $repository; $this->renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { $id = $request->getAttribute('id', false); if (! $id) { throw new RuntimeException('No book identifier provided', 400); } $book = $this->repository->get($id); $resource = new HalResource((array) $book); $resource = $resource->withLink(new Link('self')); return new TextResponse( $this->renderer->render($resource), 200, ['Content-Type' => 'application/hal+json'] ); } } The JsonRenderer returns the JSON string representing the data and links in the resource. The payload generated might look like the following: { \"_links\": { \"self\": { \"href\": \"/api/books/1234\" } }, \"id\": 1234, \"title\": \"Hitchhiker's Guide to the Galaxy\", \"author\": \"Adams, Douglas\" } The above example uses no metadata, and manually creates the HalResource instance. As the complexity of your objects increase, and the number of objects you want to represent via HAL increases, you may not want to manually generate them. Request handler using the ResourceGenerator and ResponseFactory In this next example, our request handler will compose a Zend\\Expressive\\Hal\\ResourceGenerator instance for generating a Zend\\Expressive\\Hal\\HalResource from our objects, and a Zend\\Expressive\\Hal\\HalResponseFactory for creating a response based on the returned resource. First, we'll look at a handler that displays a single book. We'll assume that Api\\Books\\Repository handles retrieving data from persistent storage. namespace Api\\Books\\Action; use Api\\Books\\Repository; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use RuntimeException; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class BookAction implements RequestHandlerInterface { /** @var Repository */ private $repository; /** @var ResourceGenerator */ private $resourceGenerator; /** @var HalResponseFactory */ private $responseFactory; public function __construct( Repository $repository, ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory ) { $this->repository = $repository; $this->resourceGenerator = $resourceGenerator; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { $id = $request->getAttribute('id', false); if (! $id) { throw new RuntimeException('No book identifier provided', 400); } /** @var \\Api\\Books\\Book $book */ $book = $this->repository->get($id); $resource = $this->resourceGenerator->fromObject($book, $request); return $this->responseFactory->createResponse($request, $resource); } } Note that the $request instance is passed to both the resource generator and response factory: The request is used by the resource generator during link URI generation. The request is used by the response factory to determine if a JSON or XML payload should be generated. The generated payload might look like the following: { \"_links\": { \"self\": { \"href\": \"/api/books/1234\" } }, \"id\": 1234, \"title\": \"Hitchhiker's Guide to the Galaxy\", \"author\": \"Adams, Douglas\" } Request handler returning a collection Next, we'll create a request handler that returns a collection of books. The collection will be paginated (assume our repository class creates a BookCollection backed by an appropriate adapter), and use a query string parameter to determine which page of results to return. namespace Api\\Books\\Action; use Api\\Books\\Repository; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use RuntimeException; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class BooksAction implements RequestHandlerInterface { /** @var Repository */ private $repository; /** @var ResourceGenerator */ private $resourceGenerator; /** @var HalResponseFactory */ private $responseFactory; public function __construct( Repository $repository, ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory ) { $this->repository = $repository; $this->resourceGenerator = $resourceGenerator; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { $page = $request->getQueryParams()['page'] ?? 1; /** @var \\Api\\Books\\BookCollection $books */ $books = $this->repository->fetchAll(); $books->setItemCountPerPage(25); $books->setCurrentPageNumber($page); $resource = $this->resourceGenerator->fromObject($books, $request); return $this->responseFactory->createResponse($request, $resource); } } Note that resource and response generation is exactly the same as our previous example! This is because the metadata map takes care of the details of extracting the data from our value objects and generating links for us. In this particular example, since we are using a paginator for our collection class, we might get back something like the following: { \"_links\": { \"self\": { \"href\": \"/api/books?page=7\" }, \"first\": { \"href\": \"/api/books?page=1\" }, \"prev\": { \"href\": \"/api/books?page=6\" }, \"next\": { \"href\": \"/api/books?page=8\" }, \"last\": { \"href\": \"/api/books?page=17\" } \"search\": { \"href\": \"/api/books?query={searchTerms}\", \"templated\": true } }, \"_embedded\": { \"book\": [ { \"_links\": { \"self\": { \"href\": \"/api/books/1234\" } } \"id\": 1234, \"title\": \"Hitchhiker's Guide to the Galaxy\", \"author\": \"Adams, Douglas\" }, { \"_links\": { \"self\": { \"href\": \"/api/books/6789\" } } \"id\": 6789, \"title\": \"Ancillary Justice\", \"author\": \"Leckie, Ann\" }, /* ... */ ] }, \"_page\": 7, \"_per_page\": 25, \"_total\": 407 } Next steps The above examples demonstrate setting up your application to generate and return HAL resources. In the following chapters, we'll cover: what HAL is, in depth. the HalResource and Link classes, so you can create your own custom resources. the MetadataMap and how to both interact with it manually as well as configure it. We'll also cover creating custom metadata types. The ResourceGenerator , and how you can map metadata types to strategies that generate representations.","title":"Introduction"},{"location":"intro/#zend-expressive-hal","text":"This component provides tools for generating Hypertext Application Language (HAL) payloads for your APIs, in both JSON and XML formats. At its core, it features: Zend\\Expressive\\Hal\\Link , a value object for describing relational links . Zend\\Expressive\\Hal\\HalResource , a value object for describing your API resource, its relational links, and any embedded/child resources related to it. These two tools allow you to model payloads of varying complexity. To allow providing representations of these, we provide Zend\\Expressive\\Hal\\HalResponseFactory . This factory generates a PSR-7 response for the provided resource, including its links and any embedded/child resources it composes. Creating link URIs by hand is error-prone, as URI schemas may change; most frameworks provide route-based URI generation for this reason. To address this, we provide Zend\\Expressive\\Hal\\LinkGenerator , and an accompanying interface, Zend\\Expressive\\Hal\\LinkGenerator\\UrlGenerator . You may use these to generate Link instances that use URIs based on routes you have defined in your application. We also ship Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator , which provides a UrlGenerator implementation backed by the zend-expressive-helpers package. Finally, we recognize that most modern PHP applications use strong data modeling, and thus API payloads need to represent PHP objects . To facilitate this, we provide two components: Zend\\Expressive\\Hal\\Metadata is a subcomponent that allows mapping PHP objects to how they should be represented: Should a route be used to generate its self relational link? What zend-hydrator extractor should be used to create a representation of the object? Does the object represent a collection? etc. Zend\\Expressive\\Hal\\ResourceGenerator consumes metadata in order to generate HalResource instances, mapping metadata to specific representation strategies. The purpose of the package is to automate creation of HAL payloads, including relational links, from PHP objects.","title":"zend-expressive-hal"},{"location":"intro/#installation","text":"Use Composer: $ composer require zendframework/zend-expressive-hal If you are adding this to an Expressive application, and have the zend-component-installer package installed, this will prompt you to ask if you wish to add it to your application configuration; please do, as the package provides a number of useful factories. We also recommend installing zend-hydrator , which provides facilities for extracting associative array representations of PHP objects: $ composer require zendframework/zend-hydrator Finally, if you want to provide paginated collections, we recommend installing zend-paginator : $ composer require zendframework/zend-paginator","title":"Installation"},{"location":"intro/#quick-start","text":"The following examples assume that you have added this package to an Expressive application.","title":"Quick Start"},{"location":"intro/#next-steps","text":"The above examples demonstrate setting up your application to generate and return HAL resources. In the following chapters, we'll cover: what HAL is, in depth. the HalResource and Link classes, so you can create your own custom resources. the MetadataMap and how to both interact with it manually as well as configure it. We'll also cover creating custom metadata types. The ResourceGenerator , and how you can map metadata types to strategies that generate representations.","title":"Next steps"},{"location":"links-and-resources/","text":"Links and Resources The basic building blocks of this component are links and resources: Zend\\Expressive\\Hal\\Link Zend\\Expressive\\Hal\\HalResource Note on naming Why HalResource and not the simpler Resource ? The answer: PHP. As of PHP 7, resource has been designated a potential future language keyword. In order to be forwards compatible, we opted to name our class HalResource . PSR-13 zendframework/zend-expressive-hal implements PSR-13 , which provides interfaces for relational links and collections of relational links. Zend\\Expressive\\Hal\\Link implements Psr\\Link\\EvolvableLinkInterface , and Zend\\Expressive\\Hal\\HalResource implements Psr\\Link\\EvolvableLinkProviderInterface . Resources compose links, so we'll cover links first. Links Links provide URIs to related resources. Any given link, therefore, needs to compose the relation and a URI . Additionally, links: can be templated . Templated links have one or more {variable} placeholders in them that clients can then fill in in order to generate a fully qualified URI. can contain a number of other attributes: type, title, name, etc. To model these, we provide the Zend\\Expressive\\Hal\\Link class. It has the following constructor: public function __construct( $relation, string $uri = '', bool $isTemplated = false, array $attributes = [] ) $relation can be a string value, or an array of string values, representing the relation. To access these various properties, you can use the following methods: $link->getRels() // get the list of relations for the link $link->getHref() // retrieve the URI $link->isTemplated() // is the link templated? $link->getAttributes() // get any additional link attributes A Link is immutable ; you cannot change it after the fact. If you need a modified version of the link, we provide several methods that will return new instances containing the changes: $link = $link->withRel($rel); // or provide an array of relations $link = $link->withoutRel($rel); // or provide an array of relations $link = $link->withHref($href); $link = $link->withAttribute($attribute, $value); $link = $link->withoutAttribute($attribute); With these tools, you can describe any relational link. Route-based link URIs Most frameworks provide routing capabilities, and delegate URI generation to their routers to ensure that generated links conform to known routing specifications. Link expects only a string URI, however; how can you prevent hard-coding that URI? This component provides a tool for that: Zend\\Expressive\\Hal\\LinkGenerator . This class composes a Zend\\Expressive\\Hal\\LinkGenerator\\UrlGeneratorInterface instance, which defines the following: namespace Zend\\Expressive\\Hal\\LinkGenerator; use Psr\\Http\\Message\\ServerRequestInterface; interface UrlGeneratorInterface { /** * Generate a URL for use as the HREF of a link. * * - The request is provided, to allow the implementation to pull any * request-specific items it may need (e.g., results of routing, original * URI for purposes of generating a fully-qualified URI, etc.). * * - `$routeParams` are any replacements to make in the route string. * * - `$queryParams` are any query string parameters to include in the * generated URL. */ public function generate( ServerRequestInterface $request, string $routeName, array $routeParams = [], array $queryParams = [] ) : string; } We provide a default implementation for Expressive users, Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGenerator , that uses the UrlHelper and ServerUrlHelper from zend-expressive-helpers in order to generate URIs. The LinkGenerator itself defines two methods: $link = $linkGenerator->fromRoute( $relation, $request, $routeName, $routeParams, // Array of additional route parameters to inject $queryParams, // Array of query string arguments to inject $attributes // Array of Link attributes to use ); $link = $linkGenerator->templatedFromRoute( $relation, $request, $routeName, $routeParams, // Array of additional route parameters to inject $queryParams, // Array of query string arguments to inject $attributes // Array of Link attributes to use ); fromRoute() will generate a non-templated Link instance, while templatedFromRoute() generates a templated instance. If you need to generate custom links based on routing, we recommend composing the LinkGenerator in your own classes to do so. Limitation There is a known limitation with zend-router when using routes with optional parameters (e.g., /books[/:id] , where :id is optional). In such cases, if no matching parameter is provided (such as when generating a URI without an :id ), the router will raise an exception due to the missing parameter. If you encounter this issue, create separate routing entries for each optional parameter. See the issue for a comprehensive example. Resources A HAL resource is simply the representation you want to return for your API. Zend\\Expressive\\Hal\\HalResource allows you to model these representations, along with any relational links and child resources. It defines the following constructor: public function __construct( array $data = [], array $links = [], array $embedded = [] ) $data should be an associative array of data you wish to include in your representation; the only limitation is you may not use the keys _links or _embedded , as these are reserved keywords. $links should be an array of Zend\\Expressive\\Hal\\Link instances. $embedded should be an array of Zend\\Expressive\\Hal\\HalResource instances. Most often, however, you will include these with $data , as the class contains logic for identifying them. Once you have created an instance, you can access its properties: $resource->getElement($name) // retrieve an element or embedded resource by name $resource->getElements() // retrieve all elements and embedded resources $resource->getLinks() // retrieve all relational links $resource->getLinksByRel() // retrieve links for a specific relation $resource->toArray() // retrieve associative array representation HalResource instances are immutable . We provide a number of methods that allow you to create new instances with changes: $resource = $resource->withElement($name, $value); $resource = $resource->withoutElement($name); $resource = $resource->withElements($elements); $resource = $resource->embed($name, $resource); $resource = $resource->withLink($link); $resource = $resource->withoutLink($link); With these tools, you can describe any resource you want to represent.","title":"Links and Resources"},{"location":"links-and-resources/#links-and-resources","text":"The basic building blocks of this component are links and resources: Zend\\Expressive\\Hal\\Link Zend\\Expressive\\Hal\\HalResource","title":"Links and Resources"},{"location":"links-and-resources/#links","text":"Links provide URIs to related resources. Any given link, therefore, needs to compose the relation and a URI . Additionally, links: can be templated . Templated links have one or more {variable} placeholders in them that clients can then fill in in order to generate a fully qualified URI. can contain a number of other attributes: type, title, name, etc. To model these, we provide the Zend\\Expressive\\Hal\\Link class. It has the following constructor: public function __construct( $relation, string $uri = '', bool $isTemplated = false, array $attributes = [] ) $relation can be a string value, or an array of string values, representing the relation. To access these various properties, you can use the following methods: $link->getRels() // get the list of relations for the link $link->getHref() // retrieve the URI $link->isTemplated() // is the link templated? $link->getAttributes() // get any additional link attributes A Link is immutable ; you cannot change it after the fact. If you need a modified version of the link, we provide several methods that will return new instances containing the changes: $link = $link->withRel($rel); // or provide an array of relations $link = $link->withoutRel($rel); // or provide an array of relations $link = $link->withHref($href); $link = $link->withAttribute($attribute, $value); $link = $link->withoutAttribute($attribute); With these tools, you can describe any relational link.","title":"Links"},{"location":"links-and-resources/#resources","text":"A HAL resource is simply the representation you want to return for your API. Zend\\Expressive\\Hal\\HalResource allows you to model these representations, along with any relational links and child resources. It defines the following constructor: public function __construct( array $data = [], array $links = [], array $embedded = [] ) $data should be an associative array of data you wish to include in your representation; the only limitation is you may not use the keys _links or _embedded , as these are reserved keywords. $links should be an array of Zend\\Expressive\\Hal\\Link instances. $embedded should be an array of Zend\\Expressive\\Hal\\HalResource instances. Most often, however, you will include these with $data , as the class contains logic for identifying them. Once you have created an instance, you can access its properties: $resource->getElement($name) // retrieve an element or embedded resource by name $resource->getElements() // retrieve all elements and embedded resources $resource->getLinks() // retrieve all relational links $resource->getLinksByRel() // retrieve links for a specific relation $resource->toArray() // retrieve associative array representation HalResource instances are immutable . We provide a number of methods that allow you to create new instances with changes: $resource = $resource->withElement($name, $value); $resource = $resource->withoutElement($name); $resource = $resource->withElements($elements); $resource = $resource->embed($name, $resource); $resource = $resource->withLink($link); $resource = $resource->withoutLink($link); With these tools, you can describe any resource you want to represent.","title":"Resources"},{"location":"representations/","text":"Generating Representations This component provides two renderers, one each for creating JSON and XML payloads. Additionally, as noted in the introduction examples, this component provides Zend\\Expressive\\Hal\\HalResponseFactory for generating a PSR-7 response containing the HAL representation. This chapter dives into that with more detail. Renderers All renderers implement Zend\\Expressive\\Hal\\Renderer\\RendererInterface : namespace Zend\\Expressive\\Hal\\Renderer; use Zend\\Expressive\\Hal\\HalResource; interface RendererInterface { public function render(HalResource $resource) : string; } Two implementations are provided, Zend\\Expressive\\Hal\\Renderer\\JsonRenderer and Zend\\Expressive\\Hal\\Renderer\\XmlRenderer JsonRenderer The JsonRenderer constructor allows you to specify a bitmask of flags for use with json_encode() . By default, if none are provided, it uses the value of JsonRenderer::DEFAULT_JSON_FLAGS , which evaluates to: JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION When your application is in \"debug\" mode, it also adds the JSON_PRETTY_PRINT flag to the default list, in order to provide human-readable JSON output. XmlRenderer The XmlRenderer produces XML representations of HAL resources. It has no constructor arguments at this time. HalResponseFactory HalResponseFactory generates a PSR-7 response containing a representation of the provided HalResource instance. In order to keep the component agnostic of PSR-7 implementation, HalResponseFactory itself composes a callable factory capable of producing an empty PSR-7 response. As an example: use Slim\\Http\\Response; use Slim\\Http\\Stream; use Zend\\Expressive\\Hal\\HalResponseFactory; $factory = new HalResponseFactory( function () { return new Response(); } ); Additionally, the HalResponseFactory constructor can accept the following arguments, with the described defaults if none is provided: A JsonRenderer instance is created if none is provided. An XmlRenderer instance is created if none is provided. We provide a PSR-11 compatible factory for generating the HalResponseFactory , described in the factories chapter . Using the factory The factory exposes one method: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Hal\\HalResource; public function createResponse( ServerRequestInterface $request, HalResource $resource, string $mediaType = self::DEFAULT_CONTENT_TYPE ) : ResponseInterface { Generally speaking, you'll pass the current request instance, and the resource for which you want to generate a response, and the factory will return a response based on its response prototype, with the following: A Content-Type header with the base media type of application/hal . A message body containing the representation. The request instance is used to determine what representation to create, based on the Accept header. If it matches a JSON media type, a JSON representation is created, and the Content-Type will be appended with +json ; for XML, an XML representation is created, and the Content-Type will be appended with +xml . If no media type is matched, XML is generated. One practice often used is to provide a custom media type for your representations. While they will still be HAL, this allows you to document the specific structure of your resources, and potentially even validate them against JSON schema. To do this, pass the media type when creating the response: $response = $factory->createResponse( $request, $resource, 'application/vnd.book' ); Do not pass the format (e.g., +json , +xml ) when doing so; the factory will append the appropriate one based on content negotiation. Forcing collections for relations HAL allows links and embedded resources to be represented as: a single object an array of objects of the same type Internally, this package checks to see if only one of the item exists, and, if so, it will render it by itself. However, there are times you may want to force an array representation. As an example, if your resource models a car, and you have a wheels relation, it would not make sense to return a single wheel, even if that's all the car currently has associated with it. To accommodate this, we provide two features. For links, you may pass a special attribute, Zend\\Expressive\\Hal\\Link::AS_COLLECTION , with a boolean value of true ; when encountered, this will then be rendered as an array of links, even if only one link for that relation is present. $link = new Link( 'wheels', '/api/car/XXXX-YYYY-ZZZZ/wheels/111', false, [Link::AS_COLLECTION => true] ); $resource = $resource->withLink($link); In the above, you will then get the following within your representation: \"_links\": { \"wheels\": [ {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"} ] } To force an embedded resource to be rendered within an array, you have two options. First, and simplest, pass the resource within an array when calling withElement() , embed() , or passing data to the constructor: // Constructor: $resource = new HalResource(['wheels' => [$wheel]]); // withElement(): $resource = $resource->withElement('wheels', [$wheel]); // embed(): $resource = $resource->embed('wheels', [$wheel]); Alternately, you can call the HalResource::embed method with only the resource, passing the method a third argument, a flag indicating whether or not to force an array: $resource = $resource->embed('wheels', $wheel, true); In each of these cases, assuming no other wheels were provided to the final resource, you might get a representation such as the following: \"_embedded\": { \"wheels\": [ { \"_links\" => {\"self\": {\"href\": \"...\"}} \"id\": \"...\" }, ] }","title":"Representations"},{"location":"representations/#generating-representations","text":"This component provides two renderers, one each for creating JSON and XML payloads. Additionally, as noted in the introduction examples, this component provides Zend\\Expressive\\Hal\\HalResponseFactory for generating a PSR-7 response containing the HAL representation. This chapter dives into that with more detail.","title":"Generating Representations"},{"location":"representations/#renderers","text":"All renderers implement Zend\\Expressive\\Hal\\Renderer\\RendererInterface : namespace Zend\\Expressive\\Hal\\Renderer; use Zend\\Expressive\\Hal\\HalResource; interface RendererInterface { public function render(HalResource $resource) : string; } Two implementations are provided, Zend\\Expressive\\Hal\\Renderer\\JsonRenderer and Zend\\Expressive\\Hal\\Renderer\\XmlRenderer","title":"Renderers"},{"location":"representations/#halresponsefactory","text":"HalResponseFactory generates a PSR-7 response containing a representation of the provided HalResource instance. In order to keep the component agnostic of PSR-7 implementation, HalResponseFactory itself composes a callable factory capable of producing an empty PSR-7 response. As an example: use Slim\\Http\\Response; use Slim\\Http\\Stream; use Zend\\Expressive\\Hal\\HalResponseFactory; $factory = new HalResponseFactory( function () { return new Response(); } ); Additionally, the HalResponseFactory constructor can accept the following arguments, with the described defaults if none is provided: A JsonRenderer instance is created if none is provided. An XmlRenderer instance is created if none is provided. We provide a PSR-11 compatible factory for generating the HalResponseFactory , described in the factories chapter .","title":"HalResponseFactory"},{"location":"representations/#using-the-factory","text":"The factory exposes one method: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Hal\\HalResource; public function createResponse( ServerRequestInterface $request, HalResource $resource, string $mediaType = self::DEFAULT_CONTENT_TYPE ) : ResponseInterface { Generally speaking, you'll pass the current request instance, and the resource for which you want to generate a response, and the factory will return a response based on its response prototype, with the following: A Content-Type header with the base media type of application/hal . A message body containing the representation. The request instance is used to determine what representation to create, based on the Accept header. If it matches a JSON media type, a JSON representation is created, and the Content-Type will be appended with +json ; for XML, an XML representation is created, and the Content-Type will be appended with +xml . If no media type is matched, XML is generated. One practice often used is to provide a custom media type for your representations. While they will still be HAL, this allows you to document the specific structure of your resources, and potentially even validate them against JSON schema. To do this, pass the media type when creating the response: $response = $factory->createResponse( $request, $resource, 'application/vnd.book' ); Do not pass the format (e.g., +json , +xml ) when doing so; the factory will append the appropriate one based on content negotiation.","title":"Using the factory"},{"location":"representations/#forcing-collections-for-relations","text":"HAL allows links and embedded resources to be represented as: a single object an array of objects of the same type Internally, this package checks to see if only one of the item exists, and, if so, it will render it by itself. However, there are times you may want to force an array representation. As an example, if your resource models a car, and you have a wheels relation, it would not make sense to return a single wheel, even if that's all the car currently has associated with it. To accommodate this, we provide two features. For links, you may pass a special attribute, Zend\\Expressive\\Hal\\Link::AS_COLLECTION , with a boolean value of true ; when encountered, this will then be rendered as an array of links, even if only one link for that relation is present. $link = new Link( 'wheels', '/api/car/XXXX-YYYY-ZZZZ/wheels/111', false, [Link::AS_COLLECTION => true] ); $resource = $resource->withLink($link); In the above, you will then get the following within your representation: \"_links\": { \"wheels\": [ {\"href\": \"/api/car/XXXX-YYYY-ZZZZ/wheels/111\"} ] } To force an embedded resource to be rendered within an array, you have two options. First, and simplest, pass the resource within an array when calling withElement() , embed() , or passing data to the constructor: // Constructor: $resource = new HalResource(['wheels' => [$wheel]]); // withElement(): $resource = $resource->withElement('wheels', [$wheel]); // embed(): $resource = $resource->embed('wheels', [$wheel]); Alternately, you can call the HalResource::embed method with only the resource, passing the method a third argument, a flag indicating whether or not to force an array: $resource = $resource->embed('wheels', $wheel, true); In each of these cases, assuming no other wheels were provided to the final resource, you might get a representation such as the following: \"_embedded\": { \"wheels\": [ { \"_links\" => {\"self\": {\"href\": \"...\"}} \"id\": \"...\" }, ] }","title":"Forcing collections for relations"},{"location":"resource-generator/","text":"Generating Resources from PHP Objects In the previous chapter, we discussed links and resources . The primitive objects allow us to create representations easily, but do not answer one critical question: how can we create resources based on existing PHP object types? To answer that question, we provide two related features: metadata, and a resource generator. Metadata Metadata allows you to detail the requirements for generating a HAL representation of a PHP object. Metadata might include: The PHP class name to represent. A URI to use for the generated resource's self relational link. Alternately, routing information to use with the LinkGenerator . A zend-hydrator extractor to use to serialize the object to a representation. Whether or not the resource is a collection, and, if so, whether pagination is handled as a path parameter or a query string argument, the name of the parameter, etc. All metadata types inherit from Zend\\Expressive\\Hal\\Metadata\\AbstractMetadata , which defines a single method, getClass() , for retrieving the name of the PHP class to represent; all metadata are expected to inherit from this class. The component also provides four concrete metadata types, requiring the following information: Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata : string $class string $collectionRelation string $route string $paginationParam = 'page' (name of the parameter indicating the current page of results) string $paginationParamType = self::TYPE_QUERY (one of \"query\" or \"placeholder\") array $routeParams = [] (associative array of substitutions to use with the designated route) array $queryStringArguments = [] (associative array of query string arguments to include in the generated URI) Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata : string $class string $route string $extractor (string service name of the zend-hydrator hydrator to use for extracting data from the instance) string $resourceIdentifier = 'id' (name of the property uniquely identifying the resource) string $routeIdentifierPlaceholder = 'id' (name of the routing parameter that maps to the resource identifier) array $routeParams = [] (associative array of additional routing parameters to substitute when generating the URI) Zend\\Expressive\\Hal\\Metadata\\UrlBasedCollectionMetadata : string $class string $collectionRelation string $url string $paginationParam = 'page' (name of the parameter indicating the current page of results) string $paginationParamType = self::TYPE_QUERY (one of \"query\" or \"placeholder\") Zend\\Expressive\\Hal\\Metadata\\UrlBasedResourceMetadata string $class string $url string $extractor (string service name of the zend-hydrator hydrator to use for extracting data from the instance) We aggregate metadata in a Zend\\Expressive\\Hal\\Metadata\\MetadataMap instance: $bookMetadata = new RouteBasedResourceMetadata( Book::class, 'book', ObjectPropertyHydrator::class ); $booksMetadata = new RouteBasedCollectionMetadata( BookCollection::class, 'book', 'books', ); $metadataMap = new MetadataMap(); $metadataMap->add($bookMetadata); $metadataMap->add($booksMetadata); Configuration-based metadata To automate generation of the MetadataMap , we provide Zend\\Expressive\\Hal\\Metadata\\MetadataMapFactory . This factory may be used with any PSR-11 container. It utilizes the config service, and pulls its configuration from a key named after the Zend\\Expressive\\Hal\\Metadata\\MetadataMap class. Each item in the map will be an associative array. The member __class__ will describe which metadata class to create, and the remaining properties will then be used to generate an instance. As an example, the above could be configured as follows: use Api\\Books\\Book; use Api\\Books\\BookCollection; use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata; use Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata; use Zend\\Hydrator\\ObjectProperty; return [ 'Zend\\Expressive\\Hal\\Metadata\\MetadataMap' => [ [ '__class__' => RouteBasedResourceMetadata::class, 'resource_class' => Book::class, 'route' => 'book', 'extractor' => ObjectProperty::class, ], [ '__class__' => RouteBasedCollectionMetadata::class, 'collection_class' => BookCollection::class, 'collection_relation' => 'book', 'route' => 'books', ], ], ]; The rest of the parameters follow underscore delimiter naming convention: RouteBasedResourceMetadata::class resource_identifier (name of the property uniquely identifying the resource) route_identifier_placeholder (name of the routing parameter that maps to the resource identifier) route_params (associative array of substitutions to use with the designated route) RouteBasedCollectionMetadata::class pagination_param (name of the parameter indicating the current page of results) pagination_param_type (one of \"query\" or \"placeholder\") route_params (associative array of substitutions to use with the designated route) query_string_arguments (associative array of additional routing parameters to substitute when generating the URI) UrlBasedResourceMetadata::class resource_class url extractor UrlBasedCollectionMetadata::class collection_class collection_relation url pagination_param (name of the parameter indicating the current page of results) pagination_param_type (one of \"query\" or \"placeholder\") ResourceGenerator Once you have defined the metadata for the various objects you will represent in your API, you can start generating resources. Zend\\Expressive\\Hal\\ResourceGenerator has the following constructor: public function __construct( Zend\\Expressive\\Hal\\Metadata\\MetadataMap $metadataMap, Psr\\Container\\ContainerInterface $hydrators, Zend\\Expressive\\Hal\\LinkGenerator $linkGenerator ) { We described the MetadataMap in the previous section, and the LinkGenerator in the previous chapter . Hydrators are defind in the zend-hydrator component , and are objects which can hdyrate associative arrays to object instances and extract associative arrays from object instances. Generally speaking, the $hydrators instance may be any PSR-11 container, but you will generally want to use the Zend\\Hydrator\\HydratorPluginManager . Once you have your instance created, you can start generating resources: $resource = $resourceGenerator->fromObject($book, $request); (Where $request is a Psr\\Http\\Message\\ServerRequestInterface instance; the instance is passed along to the LinkGenerator in order to generate route-based URIs for Link instances.)","title":"Generating Resources"},{"location":"resource-generator/#generating-resources-from-php-objects","text":"In the previous chapter, we discussed links and resources . The primitive objects allow us to create representations easily, but do not answer one critical question: how can we create resources based on existing PHP object types? To answer that question, we provide two related features: metadata, and a resource generator.","title":"Generating Resources from PHP Objects"},{"location":"resource-generator/#metadata","text":"Metadata allows you to detail the requirements for generating a HAL representation of a PHP object. Metadata might include: The PHP class name to represent. A URI to use for the generated resource's self relational link. Alternately, routing information to use with the LinkGenerator . A zend-hydrator extractor to use to serialize the object to a representation. Whether or not the resource is a collection, and, if so, whether pagination is handled as a path parameter or a query string argument, the name of the parameter, etc. All metadata types inherit from Zend\\Expressive\\Hal\\Metadata\\AbstractMetadata , which defines a single method, getClass() , for retrieving the name of the PHP class to represent; all metadata are expected to inherit from this class. The component also provides four concrete metadata types, requiring the following information: Zend\\Expressive\\Hal\\Metadata\\RouteBasedCollectionMetadata : string $class string $collectionRelation string $route string $paginationParam = 'page' (name of the parameter indicating the current page of results) string $paginationParamType = self::TYPE_QUERY (one of \"query\" or \"placeholder\") array $routeParams = [] (associative array of substitutions to use with the designated route) array $queryStringArguments = [] (associative array of query string arguments to include in the generated URI) Zend\\Expressive\\Hal\\Metadata\\RouteBasedResourceMetadata : string $class string $route string $extractor (string service name of the zend-hydrator hydrator to use for extracting data from the instance) string $resourceIdentifier = 'id' (name of the property uniquely identifying the resource) string $routeIdentifierPlaceholder = 'id' (name of the routing parameter that maps to the resource identifier) array $routeParams = [] (associative array of additional routing parameters to substitute when generating the URI) Zend\\Expressive\\Hal\\Metadata\\UrlBasedCollectionMetadata : string $class string $collectionRelation string $url string $paginationParam = 'page' (name of the parameter indicating the current page of results) string $paginationParamType = self::TYPE_QUERY (one of \"query\" or \"placeholder\") Zend\\Expressive\\Hal\\Metadata\\UrlBasedResourceMetadata string $class string $url string $extractor (string service name of the zend-hydrator hydrator to use for extracting data from the instance) We aggregate metadata in a Zend\\Expressive\\Hal\\Metadata\\MetadataMap instance: $bookMetadata = new RouteBasedResourceMetadata( Book::class, 'book', ObjectPropertyHydrator::class ); $booksMetadata = new RouteBasedCollectionMetadata( BookCollection::class, 'book', 'books', ); $metadataMap = new MetadataMap(); $metadataMap->add($bookMetadata); $metadataMap->add($booksMetadata);","title":"Metadata"},{"location":"resource-generator/#resourcegenerator","text":"Once you have defined the metadata for the various objects you will represent in your API, you can start generating resources. Zend\\Expressive\\Hal\\ResourceGenerator has the following constructor: public function __construct( Zend\\Expressive\\Hal\\Metadata\\MetadataMap $metadataMap, Psr\\Container\\ContainerInterface $hydrators, Zend\\Expressive\\Hal\\LinkGenerator $linkGenerator ) { We described the MetadataMap in the previous section, and the LinkGenerator in the previous chapter . Hydrators are defind in the zend-hydrator component , and are objects which can hdyrate associative arrays to object instances and extract associative arrays from object instances. Generally speaking, the $hydrators instance may be any PSR-11 container, but you will generally want to use the Zend\\Hydrator\\HydratorPluginManager . Once you have your instance created, you can start generating resources: $resource = $resourceGenerator->fromObject($book, $request); (Where $request is a Psr\\Http\\Message\\ServerRequestInterface instance; the instance is passed along to the LinkGenerator in order to generate route-based URIs for Link instances.)","title":"ResourceGenerator"},{"location":"cookbook/generating-custom-links-in-middleware/","text":"Generating custom links in middleware and request handlers In most cases, you can rely on the ResourceGenerator to generate self relational links, and, in the case of paginated collections, pagination links. What if you want to generate other links to include in your resources, though? The ResourceGenerator provides access to the metadata map, hydrators, and link generator via getter methods: getMetadataMap() getHydrators() getLinkGenerator() We can thus use these in order to generate custom links as needed. Creating a custom link to include in a resource In our first scenario, we'll create a \"search\" link for a resource. We'll assume that you have composed a ResourceGenerator instance in your middleware, and assigned it to the $resourceGenerator property. The link we want to generate will look something like /api/books?query={searchParms} , and map to a route named books . $searchLink = $this->resourceGenerator ->getLinkGenerator() ->templatedFromRoute( 'search', $request, 'books', [], ['query' => '{searchTerms}'] ); You could then compose it in your resource: $resource = $resource->withLink($searchLink); Adding metadata for generated links In our second scenario, we'll consider a collection endpoint. It might include a per_page query string argument, to allow defining how many results to return per page, a sort argument, and a query argument indicating the search string. We know these at runtime , but not at the time we create our configuration, so we need to inject them after we have our metadata created, but before we generate our resource, so that the pagination links are correctly generated. $queryParams = $request->getQueryParams(); $query = $queryParams['query'] ?? ''; $perPage = $queryParams['per_page'] ?? 25; $sort = $queryParams['sort'] ?? ''; $metadataMap = $this->resourceGenerator->getMetadataMap(); $metadata = $metadataMap->get(BookCollection::class); $metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments(); if ('' !== $query) { $metadataQuery = array_merge($metadataQuery, ['query' => $query]); } if ('' !== $perPage) { $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]); } if ('' !== $sort) { $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]); } $metadata->setQueryStringArguments($metadataQuery); // ... $resource = $this->resourceGenerator->fromObject($books, $request); // Reset query string arguments $metadata->setQueryStringArguments($origMetadataQuery); This will lead to links with URIs such as /api/books?query=Adams&per_page=5&sort=DESC&page=4 .","title":"Generating Custom Links In Middleware and Request Handlers"},{"location":"cookbook/generating-custom-links-in-middleware/#generating-custom-links-in-middleware-and-request-handlers","text":"In most cases, you can rely on the ResourceGenerator to generate self relational links, and, in the case of paginated collections, pagination links. What if you want to generate other links to include in your resources, though? The ResourceGenerator provides access to the metadata map, hydrators, and link generator via getter methods: getMetadataMap() getHydrators() getLinkGenerator() We can thus use these in order to generate custom links as needed.","title":"Generating custom links in middleware and request handlers"},{"location":"cookbook/generating-custom-links-in-middleware/#creating-a-custom-link-to-include-in-a-resource","text":"In our first scenario, we'll create a \"search\" link for a resource. We'll assume that you have composed a ResourceGenerator instance in your middleware, and assigned it to the $resourceGenerator property. The link we want to generate will look something like /api/books?query={searchParms} , and map to a route named books . $searchLink = $this->resourceGenerator ->getLinkGenerator() ->templatedFromRoute( 'search', $request, 'books', [], ['query' => '{searchTerms}'] ); You could then compose it in your resource: $resource = $resource->withLink($searchLink);","title":"Creating a custom link to include in a resource"},{"location":"cookbook/generating-custom-links-in-middleware/#adding-metadata-for-generated-links","text":"In our second scenario, we'll consider a collection endpoint. It might include a per_page query string argument, to allow defining how many results to return per page, a sort argument, and a query argument indicating the search string. We know these at runtime , but not at the time we create our configuration, so we need to inject them after we have our metadata created, but before we generate our resource, so that the pagination links are correctly generated. $queryParams = $request->getQueryParams(); $query = $queryParams['query'] ?? ''; $perPage = $queryParams['per_page'] ?? 25; $sort = $queryParams['sort'] ?? ''; $metadataMap = $this->resourceGenerator->getMetadataMap(); $metadata = $metadataMap->get(BookCollection::class); $metadataQuery = $origMetadataQuery = $metadata->getQueryStringArguments(); if ('' !== $query) { $metadataQuery = array_merge($metadataQuery, ['query' => $query]); } if ('' !== $perPage) { $metadataQuery = array_merge($metadataQuery, ['per_page' => $perPage]); } if ('' !== $sort) { $metadataQuery = array_merge($metadataQuery, ['sort' => $sort]); } $metadata->setQueryStringArguments($metadataQuery); // ... $resource = $this->resourceGenerator->fromObject($books, $request); // Reset query string arguments $metadata->setQueryStringArguments($origMetadataQuery); This will lead to links with URIs such as /api/books?query=Adams&per_page=5&sort=DESC&page=4 .","title":"Adding metadata for generated links"},{"location":"cookbook/generating-custom-resources/","text":"Generating custom resources The ResourceGenerator allows composing Zend\\Expressive\\Hal\\ResourceGenerator\\StrategyInterface instances. The StrategyInterface defines the following: namespace Zend\\Expressive\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Hal\\HalResource; use Zend\\Expressive\\Hal\\Metadata; use Zend\\Expressive\\Hal\\ResourceGenerator; interface StrategyInterface { /** * @param object $instance Instance from which to create Resource. * @throws Exception\\UnexpectedMetadataTypeException for metadata types the * strategy cannot handle. */ public function createResource( $instance, Metadata\\AbstractMetadata $metadata, ResourceGenerator $resourceGenerator, ServerRequestInterface $request ) : HalResource; } When you register a strategy, you will map a metadata type to the strategy; the ResourceGenerator will then call your strategy whenever it encounteres metadata of that type. $resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class); // or: $resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance); You can also add your strategies via the configuration: return [ 'zend-expressive-hal' => [ 'resource-generator' => [ 'strategies' => [ CustomMetadata::class => CustomStrategy::class, ], ], ], ]; If a strategy already is mapped for the given metadata type, this method will override it. To facilitate common operations, this library provides two traits, Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractCollectionTrait and Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractInstanceTrait ; inspect these if you decide to write your own strategies. In order for the MetadataMap to be able to use your CustomMetadata you need to register a factory (implementing Zend\\Expressive\\Hal\\Metadata\\MetadataFactoryInterface ) for it. You can register them via the configuration: return [ 'zend-expressive-hal' => [ 'metadata-factories' => [ CustomMetadata::class => CustomMetadataFactory::class, ], ], ];","title":"Custom Resources"},{"location":"cookbook/generating-custom-resources/#generating-custom-resources","text":"The ResourceGenerator allows composing Zend\\Expressive\\Hal\\ResourceGenerator\\StrategyInterface instances. The StrategyInterface defines the following: namespace Zend\\Expressive\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Hal\\HalResource; use Zend\\Expressive\\Hal\\Metadata; use Zend\\Expressive\\Hal\\ResourceGenerator; interface StrategyInterface { /** * @param object $instance Instance from which to create Resource. * @throws Exception\\UnexpectedMetadataTypeException for metadata types the * strategy cannot handle. */ public function createResource( $instance, Metadata\\AbstractMetadata $metadata, ResourceGenerator $resourceGenerator, ServerRequestInterface $request ) : HalResource; } When you register a strategy, you will map a metadata type to the strategy; the ResourceGenerator will then call your strategy whenever it encounteres metadata of that type. $resourceGenerator->addStrategy(CustomMetadata::class, CustomStrategy::class); // or: $resourceGenerator->addStrategy(CustomMetadata::class, $strategyInstance); You can also add your strategies via the configuration: return [ 'zend-expressive-hal' => [ 'resource-generator' => [ 'strategies' => [ CustomMetadata::class => CustomStrategy::class, ], ], ], ]; If a strategy already is mapped for the given metadata type, this method will override it. To facilitate common operations, this library provides two traits, Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractCollectionTrait and Zend\\Expressive\\Hal\\ResourceGenerator\\ExtractInstanceTrait ; inspect these if you decide to write your own strategies. In order for the MetadataMap to be able to use your CustomMetadata you need to register a factory (implementing Zend\\Expressive\\Hal\\Metadata\\MetadataFactoryInterface ) for it. You can register them via the configuration: return [ 'zend-expressive-hal' => [ 'metadata-factories' => [ CustomMetadata::class => CustomMetadataFactory::class, ], ], ];","title":"Generating custom resources"},{"location":"cookbook/path-segregated-uri-generation/","text":"Using the ResourceGenerator in path-segregated middleware Since 1.1.0. You may want to develop your API as a separate module that you can then drop in to an existing application; you may even want to path-segregate it. In such cases, you will want to use a different router instance to isolate your routes, which has a huge number of ramifications: You'll need separate routing middleware. You'll need a separate UrlHelper instance, as well as its related middleware. You'll need a separate URL generator for HAL that consumes the separate UrlHelper instance. You'll need a separate LinkGenerator for HAL that consumes the separate URL generator. You'll need a separate ResourceGenerator for HAL that consumes the separate LinkGenerator . This can be accomplished by writing your own factories, but that means a lot of extra code, and the potential for it to go out-of-sync with the official factories for these services. What should you do? Virtual services Since version 1.1.0 of this package, and versions 3.1.0 of zend-expressive-router and 5.1.0 of zend-expressive-helpers, you can now pass additional constructor arguments to a number of factories to allow varying the service dependencies they look for. In our example below, we will create an Api module. This module will have its own router, and be segregated in the path /api ; all routes we create will be relative to that path, and not include it in their definitions. The handler we create will return HAL-JSON, and thus need to generate links using the configured router and base path. To begin, we will alter the ConfigProvider for our module to add the definitions noted below: // in src/Api/ConfigProvider.php: namespace Api; use Zend\\Expressive\\Hal\\LinkGeneratorFactory; use Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory; use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; use Zend\\Expressive\\Hal\\ResourceGeneratorFactory; use Zend\\Expressive\\Helper\\UrlHelperFactory; use Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouterFactory; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), MetadataMap::class => $this->getMetadataMap(), ]; } public function getDependencies() : array { return [ 'factories' => [ // module-specific class name => factory LinkGenerator::class => new LinkGeneratorFactory(UrlGenerator::class), ResourceGenerator::class => new ResourceGeneratorFactory(LinkGenerator::class), Router::class => FastRouteRouterFactory::class, RouteMiddleware::class => new RouteMiddlewareFactory(Router::class), UrlHelper::class => new UrlHelperFactory('/api', Router::class), UrlHelperMiddleware::class => new UrlHelperMiddlewareFactory(UrlHelper::class), UrlGenerator::class => new ExpressiveUrlGeneratorFactory(UrlHelper::class), // Our handler: CreateBookHandler::class => CreateBookHandlerFactory::class, // And our pipeline: Pipeline::class => PipelineFactory::class, ], ]; } public function getMetadataMap() : array { return [ // ... ]; } } Note that the majority of these service names are virtual ; they do not resolve to actual classes. PHP allows usage of the ::class pseudo-constant anywhere, and will resolve the value based on the current namespace. This gives us virtual services such as Api\\Router , Api\\UrlHelper , etc. Also note that we are creating factory instances . Normally, we recommend not using closures or instances for factories due to potential problems with configuration caching. Fortunately, we have provided functionality in each of these factories that allows them to be safely cached, retaining the context-specific configuration required. What about the hard-coded path? You'll note that the above example hard-codes the base path for the UrlHelper . What if you want to use a different path? You can override the service in an application-specific configuration under config/autoload/ , specifying a different path! $$$$FENCED_CODE_BLOCK_5dbff08d997d23.14921594 Using virtual services with a handler Now let's turn to our CreateBookHandler . We'll define it as follows: // in src/Api/CreateBookHandler.php: namespace Api; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class CreateBookHandler implements RequestHandlerInterface { private $resourceGenerator; private $responseFactory; public function __construct(ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory) { $this->resourceGenerator = $resourceGenerator; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // do some work ... $resource = $this->resourceGenerator->fromObject($book, $request); return $this->responseFactory->createResponse($request, $book); } } This handler needs a HAL resource generator. More specifically, it needs the one specific to our module. As such, we'll define our factory as follows: // in src/Api/CreateBookHandlerFactory.php: namespace Api; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; class CreateBookHandlerFactory { public function __invoke(ContainerInterface $container) : CreateBookHandler { return new CreateBookHandler( ResourceGenerator::class, // module-specific service name! HalResponseFactory::class ); } } You can create any number of such handlers for your module; the above demonstrates how and where injection of the alternate resource generator occurs. Creating our pipeline and routes Now we can create our pipeline and routes. Generally when piping to an application instance, we can specify a class name of middleware to pipe, or an array of middleware: // in config/pipeline.php: $app->pipe('/api', [ \\Zend\\ProblemDetails\\ProblemDetailsMiddleware::class, \\Api\\RouteMiddleware::class, // module-specific routing middleware! ImplicitHeadMiddleware::class, ImplicitOptionsMiddleware::class, MethodNotAllowedMiddleware::class, \\Api\\UrlHelperMiddleware::class, // module-specific URL helper middleware! DispatchMiddleware::class, \\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class, ]); However, we have both the pipeline and routes, and we likely want to indicate the exact behavior of this pipeline. Additionally, we may want to re-use this pipeline in other applications; pushing this into the application configuration makes that more error-prone. As such, we will create a factory that generates and returns a Zend\\Stratigility\\MiddlewarePipe instance that is fully configured for our module. As part of this functionality, we will also add our module-specific routing. // In src/Api/PipelineFactory.php: namespace Api; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Router\\Middleware as RouterMiddleware; use Zend\\Expressive\\Router\\RouteCollector; use Zend\\ProblemDetails\\ProblemDetailsMiddleware; use Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler; use Zend\\Stratigility\\MiddlewarePipe; class PipelineFactory { public function __invoke(ContainerInterface $container) : MiddlewarePipe { $factory = $container->get(MiddlewareFactory::class); // First, create our middleware pipeline $pipeline = new MiddlewarePipe(); $pipeline->pipe($factory->lazy(ProblemDetailsMiddleware::class)); $pipeline->pipe($factory->lazy(RouteMiddleware::class)); // module-specific! $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitHeadMiddleware::class)); $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitOptionsMiddleware::class)); $pipeline->pipe($factory->lazy(RouterMiddleware\\MethodNotAllowedMiddleware::class)); $pipeline->pipe($factory->lazy(UrlHelperMiddleware::class)); // module-specific! $pipeline->pipe($factory->lazy(RouterMiddleware\\DispatchMiddleware::class)); $pipeline->pipe($factory->lazy(ProblemDetailsNotFoundHandler::class)); // Second, we'll create our routes $router = $container->get(Router::class); // Retrieve our module-specific router $routes = new RouteCollector($router); // Create a route collector to simplify routing // Start routing: $routes->post('/books', $factory->lazy(CreateBookHandler::class)); // Return the pipeline now that we're done! return $pipeline; } } Note that the routing definitions do not include the prefix /api ; this is because that prefix will be stripped when we path-segregate our API middleware pipeline. All routing will be relative to that path. Creating a path-segregated pipeline Finally, we will attach our pipeline to the application, using path segregation: // in config/pipeline.php: $app->pipe('/api', \\Api\\Pipeline::class); This statement tells the application to pipe the pipeline returned by our PipelineFactory under the path /api ; that path will be stripped from requests when passed to the underlying middleware. At this point, we now have a re-usable module, complete with its own routing, with URI generation that will include the base path under which we have segregated the pipeline!","title":"Using the ResourceGenerator in path-segregated middleware"},{"location":"cookbook/path-segregated-uri-generation/#using-the-resourcegenerator-in-path-segregated-middleware","text":"Since 1.1.0. You may want to develop your API as a separate module that you can then drop in to an existing application; you may even want to path-segregate it. In such cases, you will want to use a different router instance to isolate your routes, which has a huge number of ramifications: You'll need separate routing middleware. You'll need a separate UrlHelper instance, as well as its related middleware. You'll need a separate URL generator for HAL that consumes the separate UrlHelper instance. You'll need a separate LinkGenerator for HAL that consumes the separate URL generator. You'll need a separate ResourceGenerator for HAL that consumes the separate LinkGenerator . This can be accomplished by writing your own factories, but that means a lot of extra code, and the potential for it to go out-of-sync with the official factories for these services. What should you do?","title":"Using the ResourceGenerator in path-segregated middleware"},{"location":"cookbook/path-segregated-uri-generation/#virtual-services","text":"Since version 1.1.0 of this package, and versions 3.1.0 of zend-expressive-router and 5.1.0 of zend-expressive-helpers, you can now pass additional constructor arguments to a number of factories to allow varying the service dependencies they look for. In our example below, we will create an Api module. This module will have its own router, and be segregated in the path /api ; all routes we create will be relative to that path, and not include it in their definitions. The handler we create will return HAL-JSON, and thus need to generate links using the configured router and base path. To begin, we will alter the ConfigProvider for our module to add the definitions noted below: // in src/Api/ConfigProvider.php: namespace Api; use Zend\\Expressive\\Hal\\LinkGeneratorFactory; use Zend\\Expressive\\Hal\\LinkGenerator\\ExpressiveUrlGeneratorFactory; use Zend\\Expressive\\Hal\\Metadata\\MetadataMap; use Zend\\Expressive\\Hal\\ResourceGeneratorFactory; use Zend\\Expressive\\Helper\\UrlHelperFactory; use Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouterFactory; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' => $this->getDependencies(), MetadataMap::class => $this->getMetadataMap(), ]; } public function getDependencies() : array { return [ 'factories' => [ // module-specific class name => factory LinkGenerator::class => new LinkGeneratorFactory(UrlGenerator::class), ResourceGenerator::class => new ResourceGeneratorFactory(LinkGenerator::class), Router::class => FastRouteRouterFactory::class, RouteMiddleware::class => new RouteMiddlewareFactory(Router::class), UrlHelper::class => new UrlHelperFactory('/api', Router::class), UrlHelperMiddleware::class => new UrlHelperMiddlewareFactory(UrlHelper::class), UrlGenerator::class => new ExpressiveUrlGeneratorFactory(UrlHelper::class), // Our handler: CreateBookHandler::class => CreateBookHandlerFactory::class, // And our pipeline: Pipeline::class => PipelineFactory::class, ], ]; } public function getMetadataMap() : array { return [ // ... ]; } } Note that the majority of these service names are virtual ; they do not resolve to actual classes. PHP allows usage of the ::class pseudo-constant anywhere, and will resolve the value based on the current namespace. This gives us virtual services such as Api\\Router , Api\\UrlHelper , etc. Also note that we are creating factory instances . Normally, we recommend not using closures or instances for factories due to potential problems with configuration caching. Fortunately, we have provided functionality in each of these factories that allows them to be safely cached, retaining the context-specific configuration required.","title":"Virtual services"},{"location":"cookbook/path-segregated-uri-generation/#using-virtual-services-with-a-handler","text":"Now let's turn to our CreateBookHandler . We'll define it as follows: // in src/Api/CreateBookHandler.php: namespace Api; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; use Zend\\Expressive\\Hal\\ResourceGenerator; class CreateBookHandler implements RequestHandlerInterface { private $resourceGenerator; private $responseFactory; public function __construct(ResourceGenerator $resourceGenerator, HalResponseFactory $responseFactory) { $this->resourceGenerator = $resourceGenerator; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // do some work ... $resource = $this->resourceGenerator->fromObject($book, $request); return $this->responseFactory->createResponse($request, $book); } } This handler needs a HAL resource generator. More specifically, it needs the one specific to our module. As such, we'll define our factory as follows: // in src/Api/CreateBookHandlerFactory.php: namespace Api; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Hal\\HalResponseFactory; class CreateBookHandlerFactory { public function __invoke(ContainerInterface $container) : CreateBookHandler { return new CreateBookHandler( ResourceGenerator::class, // module-specific service name! HalResponseFactory::class ); } } You can create any number of such handlers for your module; the above demonstrates how and where injection of the alternate resource generator occurs.","title":"Using virtual services with a handler"},{"location":"cookbook/path-segregated-uri-generation/#creating-our-pipeline-and-routes","text":"Now we can create our pipeline and routes. Generally when piping to an application instance, we can specify a class name of middleware to pipe, or an array of middleware: // in config/pipeline.php: $app->pipe('/api', [ \\Zend\\ProblemDetails\\ProblemDetailsMiddleware::class, \\Api\\RouteMiddleware::class, // module-specific routing middleware! ImplicitHeadMiddleware::class, ImplicitOptionsMiddleware::class, MethodNotAllowedMiddleware::class, \\Api\\UrlHelperMiddleware::class, // module-specific URL helper middleware! DispatchMiddleware::class, \\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class, ]); However, we have both the pipeline and routes, and we likely want to indicate the exact behavior of this pipeline. Additionally, we may want to re-use this pipeline in other applications; pushing this into the application configuration makes that more error-prone. As such, we will create a factory that generates and returns a Zend\\Stratigility\\MiddlewarePipe instance that is fully configured for our module. As part of this functionality, we will also add our module-specific routing. // In src/Api/PipelineFactory.php: namespace Api; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Router\\Middleware as RouterMiddleware; use Zend\\Expressive\\Router\\RouteCollector; use Zend\\ProblemDetails\\ProblemDetailsMiddleware; use Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler; use Zend\\Stratigility\\MiddlewarePipe; class PipelineFactory { public function __invoke(ContainerInterface $container) : MiddlewarePipe { $factory = $container->get(MiddlewareFactory::class); // First, create our middleware pipeline $pipeline = new MiddlewarePipe(); $pipeline->pipe($factory->lazy(ProblemDetailsMiddleware::class)); $pipeline->pipe($factory->lazy(RouteMiddleware::class)); // module-specific! $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitHeadMiddleware::class)); $pipeline->pipe($factory->lazy(RouterMiddleware\\ImplicitOptionsMiddleware::class)); $pipeline->pipe($factory->lazy(RouterMiddleware\\MethodNotAllowedMiddleware::class)); $pipeline->pipe($factory->lazy(UrlHelperMiddleware::class)); // module-specific! $pipeline->pipe($factory->lazy(RouterMiddleware\\DispatchMiddleware::class)); $pipeline->pipe($factory->lazy(ProblemDetailsNotFoundHandler::class)); // Second, we'll create our routes $router = $container->get(Router::class); // Retrieve our module-specific router $routes = new RouteCollector($router); // Create a route collector to simplify routing // Start routing: $routes->post('/books', $factory->lazy(CreateBookHandler::class)); // Return the pipeline now that we're done! return $pipeline; } } Note that the routing definitions do not include the prefix /api ; this is because that prefix will be stripped when we path-segregate our API middleware pipeline. All routing will be relative to that path.","title":"Creating our pipeline and routes"},{"location":"cookbook/path-segregated-uri-generation/#creating-a-path-segregated-pipeline","text":"Finally, we will attach our pipeline to the application, using path segregation: // in config/pipeline.php: $app->pipe('/api', \\Api\\Pipeline::class); This statement tells the application to pipe the pipeline returned by our PipelineFactory under the path /api ; that path will be stripped from requests when passed to the underlying middleware. At this point, we now have a re-usable module, complete with its own routing, with URI generation that will include the base path under which we have segregated the pipeline!","title":"Creating a path-segregated pipeline"}]}